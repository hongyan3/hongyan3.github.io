## Redis

### 1. 缓存穿透

缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，进而给数据库带来压力。

1. **缓存空数据**

查询返回的数据为空，仍把这个结果进行缓存

- 优点：简单

- 缺点：消耗内存，可能存在不一致的问题

> 不一致指高并发环境下，插入key值，还未更新缓存便返回旧缓存值NUL

2. **布隆过滤器**

![image-20231121001322480](https://s2.loli.net/2024/03/08/VjP7lWdLArZTXKJ.png)

- 优点：内存占用少，没有多余的key
- 缺点：实现复杂，存在误判

> 对于误判率，一般情况下设置为不超过5%，在高并发环境下不至于压倒数据库



### 2. 缓存击穿

给某个key设置了过期时间，当key过期的时候，恰好这个时间点对这个key有大量的并发请求，这些并发请求可能会瞬间将数据库压垮

1. **分布式锁（互斥锁）**：强一致、性能差
2. **逻辑过期**：高可用、性能优，不能保证性能绝对一致

![image-20231121204114184](https://s2.loli.net/2024/03/08/uSkzh6psKWXrEeI.png)



### 3. 缓存雪崩

指在同一时间段内，大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力

1. 给不同的key的TTL添加随机值
2. 利用Redis集群提高服务可用性
3. 给缓存业务添加降级限流策略（保底）
4. 给业务添加多级缓存



### 4. 双写一致

指修改了数据库的数据也要同时更新缓存数据，缓存和数据库的数据保持一致

需要分析业务场景数据是否需要强一致性

1. **允许延时一致的业务**， 采取异步通知
   - MQ中间件，更新数据后，通知缓存删除
   - Canal中间件，不需要修改业务代码，伪装成MySql的一个从节点，Canal通过读取binlog数据更新缓存
   - 延时双删（存在脏数据）
2. **强一致的**，采用Redisson提供的读写锁
   - 共享锁：读锁readLock，加锁之后其他线程可用共享读操作
   - 排他锁：写锁writeLock，也叫独占锁，加锁之后堵塞其他线程读写操作



### 5. Redis持久化

1. **RDB**

   全称Redis Databases Backup File（Redis数据备份文件），也叫做Redis数据快照文件。

   - save：由Redis主进程来执行RDB，会阻塞所有命令

   - bgsave：由Redis子进程来支持RDB，避免主进程受到影响

   > **RDB的执行原理**：bgsave会fork主进程得到子进程，子进程共享主进程的内存数据，完成fork后读取内存数据并写入RDB文件

2. **AOF**

   全称Append Only File（追加文件），Redis处理的每一个写命令都会记录在AOF文件，可以看作是命令日志文件。

   ![image-20231121213222105](https://s2.loli.net/2024/03/08/AUDYzZyH5n9cfgN.png)

   > 因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的多次写操作，但只有最后一次写操作才有意义。通过执行**bgrewriteaof**命令，可以让AOF文件执行重写功能，用最少的命令达到相同效果。

   

![image-20231121213738023](https://s2.loli.net/2024/03/08/QjnMtSsLOKCYBXJ.png)



### 6. Redis数据删除策略

1. **惰性删除**

   设置key的过期时间后，只有在需要这个key的时候才去检查它是否过期，如果过期则删除，反之则返回数据

   - 优点：对CPU友好，对于很多用不到的key不必花时间去进行过期检查
   - 缺点：对内存不友好，如果key过期，但一直未使用，则会一直存在内存中，永不释放

2. **定期删除**

   每隔一段时间就对一些随机的key进行检查，删除里面过期的key

   定期删除有两种模式：

   - SLOW模式是定时任务，执行频率默认10hz，可通过配置文件修改
   - FAST模式执行频率不固定，但两次间隔不低于2ms，每次耗时不超过1ms

   **优点**：可以通过限制删除操作的时长和频率来减少对CPU的影响，同时也能有效释放内存中的key

   **缺点**：难以确定删除操作的时间和频率

   

Redis的过期删除策略：**惰性删除** + **定期删除**两种策略配合使用



### 7. Redis的数据淘汰策略

指当Redis中的内存不够用时，此时向Redis中添加新的key，Redis就会按照某种策略将内存中的数据删除，这种策略就叫做数据淘汰策略

- **LRU（Last Recently Used**最近最少使用。用当前的时间减去最后一次的访问时间，这个值越大则淘汰优先级越高

- **LFU（Last Frequently Used**最少频率使用。统计每一个key的访问频率，值越小，淘汰优先级越高

### 8. Redis分布式锁

1. 分布式锁的实现

   通常使用**redisson**来实现分布式锁，底层使用**setnx**和**lua**脚本（保证原子性）

2. 合理控制锁的有效时间

   Redisson的分布式锁中，提供了**WatchDog（看门狗）**机制，一个线程获取锁成功后，WatchDog会对持有锁的线程**续期**（默认每隔10s续一次）

3. 可重入锁

   redisson的分布式锁可以重入，在redis中使用**hash**来存储**线程信息和重入次数**

4. 主从一致性

   redisson**不能解决**主从数据一致的问题，但是可以通过**红锁**来实现，但是**性能太低**，如果要保证业务的强一致性，建议采用**zookeeper**实现的分布式锁

   RedLock（红锁）：不能只在一个实例上创建锁，应该在多个实例上（n/2+1）创建锁

### 9. Redis集群方案

1. 主从复制（读写分离）

   一般都是一主多从，主节点负责写数据，从节点负责读数据

   - 主从全量同步

     ![image-20231123211000628](https://s2.loli.net/2024/03/08/XbEeSaqkrVY9gm4.png)

   - 主从增量同步

     ![image-20231123211229609](https://s2.loli.net/2024/03/08/VYTP5ktdbcvBxZR.png)

2. 哨兵模式

   - 哨兵模式的作用
    ![image-20240320152052007](https://s2.loli.net/2024/03/20/MyHDx9YJGn7qeul.png)

   - 服务状态监控

     ![image-20240320152220254](https://s2.loli.net/2024/03/20/WYFQgNcyV6a5rLO.png)
     
   - 集群**脑裂**

     ![image-20240320152431151](https://s2.loli.net/2024/03/20/vFq7Rag6cGOT5mi.png)

3. 分片集群

   ![image-20240320151601733](https://s2.loli.net/2024/03/20/6id45KqCnyETprv.png)

   - 分片集群的作用
     - 集群中有多个master，每个master保存不同的数据
     - 每个master都可以有多个slave节点
     - master之间通过ping监测彼此健康状态
     - 客户端可以访问集群任意节点，最终都会被转发到正确的节点

### 10. Redis为什么快

- 基于内存

- 单线程，没有上下文切换

- I/O多路复用

  - **阻塞IO**

    ![image-20240320154737061](https://s2.loli.net/2024/03/20/ntskhKZdq4VQebI.png)

  - **非阻塞IO**

    ![image-20240320154826212](https://s2.loli.net/2024/03/20/CVAisNuotFhXPrv.png)

  - **IO多路复用**

    ![image-20240320155136805](https://s2.loli.net/2024/03/20/exL1qNJAk6zYwp8.png)

