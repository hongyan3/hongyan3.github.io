## Redis

### 1. 缓存穿透

缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，进而给数据库带来压力。

1. **缓存空数据**

查询返回的数据为空，仍把这个结果进行缓存

- 优点：简单

- 缺点：消耗内存，可能存在不一致的问题

> 不一致指高并发环境下，插入key值，还未更新缓存便返回旧缓存值NUL

2. **布隆过滤器**

![image-20231121001322480](https://s2.loli.net/2024/03/08/VjP7lWdLArZTXKJ.png)

- 优点：内存占用少，没有多余的key
- 缺点：实现复杂，存在误判

> 对于误判率，一般情况下设置为不超过5%，在高并发环境下不至于压倒数据库



### 2. 缓存击穿

给某个key设置了过期时间，当key过期的时候，恰好这个时间点对这个key有大量的并发请求，这些并发请求可能会瞬间将数据库压垮

1. **分布式锁（互斥锁）**：强一致、性能差
2. **逻辑过期**：高可用、性能优，不能保证性能绝对一致

![image-20231121204114184](https://s2.loli.net/2024/03/08/uSkzh6psKWXrEeI.png)



### 3. 缓存雪崩

指在同一时间段内，大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力

1. 给不同的key的TTL添加随机值
2. 利用Redis集群提高服务可用性
3. 给缓存业务添加降级限流策略（保底）
4. 给业务添加多级缓存



### 4. 双写一致

指修改了数据库的数据也要同时更新缓存数据，缓存和数据库的数据保持一致

需要分析业务场景数据是否需要强一致性

1. **允许延时一致的业务**， 采取异步通知
   - MQ中间件，更新数据后，通知缓存删除
   - Canal中间件，不需要修改业务代码，伪装成MySql的一个从节点，Canal通过读取binlog数据更新缓存
   - 延时双删（存在脏数据）
2. **强一致的**，采用Redisson提供的读写锁
   - 共享锁：读锁readLock，加锁之后其他线程可用共享读操作
   - 排他锁：写锁writeLock，也叫独占锁，加锁之后堵塞其他线程读写操作



### 5. Redis持久化

1. **RDB**

   全称Redis Databases Backup File（Redis数据备份文件），也叫做Redis数据快照文件。

   - save：由Redis主进程来执行RDB，会阻塞所有命令

   - bgsave：由Redis子进程来支持RDB，避免主进程受到影响

   > **RDB的执行原理**：bgsave会fork主进程得到子进程，子进程共享主进程的内存数据，完成fork后读取内存数据并写入RDB文件

2. **AOF**

   全称Append Only File（追加文件），Redis处理的每一个写命令都会记录在AOF文件，可以看作是命令日志文件。

   ![image-20231121213222105](https://s2.loli.net/2024/03/08/AUDYzZyH5n9cfgN.png)

   > 因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的多次写操作，但只有最后一次写操作才有意义。通过执行**bgrewriteaof**命令，可以让AOF文件执行重写功能，用最少的命令达到相同效果。

   

![image-20231121213738023](https://s2.loli.net/2024/03/08/QjnMtSsLOKCYBXJ.png)



### 6. Redis数据删除策略

1. **惰性删除**

   设置key的过期时间后，只有在需要这个key的时候才去检查它是否过期，如果过期则删除，反之则返回数据

   - 优点：对CPU友好，对于很多用不到的key不必花时间去进行过期检查
   - 缺点：对内存不友好，如果key过期，但一直未使用，则会一直存在内存中，永不释放

2. **定期删除**

   每隔一段时间就对一些随机的key进行检查，删除里面过期的key

   定期删除有两种模式：

   - SLOW模式是定时任务，执行频率默认10hz，可通过配置文件修改
   - FAST模式执行频率不固定，但两次间隔不低于2ms，每次耗时不超过1ms

   **优点**：可以通过限制删除操作的时长和频率来减少对CPU的影响，同时也能有效释放内存中的key

   **缺点**：难以确定删除操作的时间和频率

   

Redis的过期删除策略：**惰性删除** + **定期删除**两种策略配合使用



### 7. Redis的数据淘汰策略

指当Redis中的内存不够用时，此时向Redis中添加新的key，Redis就会按照某种策略将内存中的数据删除，这种策略就叫做数据淘汰策略

- **LRU（Last Recently Used）**最近最少使用。用当前的时间减去最后一次的访问时间，这个值越大则淘汰优先级越高

- **LFU（Last Frequently Used）**最少频率使用。统计每一个key的访问频率，值越小，淘汰优先级越高

### 8. Redis分布式锁

1. 分布式锁的实现

   通常使用**redisson**来实现分布式锁，底层使用**setnx**和**lua**脚本（保证原子性）

2. 合理控制锁的有效时间

   Redisson的分布式锁中，提供了**WatchDog（看门狗）**机制，一个线程获取锁成功后，WatchDog会对持有锁的线程**续期**（默认每隔10s续一次）

3. 可重入锁

   redisson的分布式锁可以重入，在redis中使用**hash**来存储**线程信息和重入次数**

4. 主从一致性

   redisson**不能解决**主从数据一致的问题，但是可以通过**红锁**来实现，但是**性能太低**，如果要保证业务的强一致性，建议采用**zookeeper**实现的分布式锁

   RedLock（红锁）：不能只在一个实例上创建锁，应该在多个实例上（n/2+1）创建锁

### 9. Redis集群方案

1. 主从复制（读写分离）

   一般都是一主多从，主节点负责写数据，从节点负责读数据

   - 主从全量同步

     ![image-20231123211000628](https://s2.loli.net/2024/03/08/XbEeSaqkrVY9gm4.png)

   - 主从增量同步

     ![image-20231123211229609](https://s2.loli.net/2024/03/08/VYTP5ktdbcvBxZR.png)



## MySQL

### 1. 慢查询

如何定位慢查询？

1. 方案一：开源工具

   - 调试工具：Arthas
   - 运维工具：Prometheus、Skywalking

2. 方案二：MySQL自带满日志

   ![image-20231229160532627](https://s2.loli.net/2024/03/08/YFwzVjXftAPMenl.png)

如何分析慢SQL语句？

1. 采用`EXPLAIN`或者`DESC`命令获取MySQL如何执行SELECT语句

   ![image-20231230134440074](https://s2.loli.net/2024/03/08/cYrsXDemf5R2hOq.png)![image-20231230135158620]

> 如果SQL的type是`index`或者`all`时，就需要优化



### 2. 索引

什么是索引？

索引（index）是帮助MySQL**高效获取**数据的数据结构结构（有序）。在数据之外，数据库系统还维护着满足特定查找算法的数据结构（**B+树**），这些数据以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。



B+树和B树的对比

B+Tree是在BTree基础上的一种优化，使其更合适实现外存储索引结构，InnoDB存储引擎就是用B+树实现其索引结构

![image-20231230215211312](https://s2.loli.net/2024/03/08/zqdkH3lEK1sIx96.png)

区别：

1. 磁盘读写代价B+树更低（B+树只在叶子结点存储数据）
2. 查询效率B+树更加稳定
3. B+树便于扫库和区间查询，叶子结点之间是双向链表



聚簇索引与非聚簇索引

![image-20231230215620758](https://s2.loli.net/2024/03/08/Fg1tbIRyZvJm2oC.png)



回表查询

通过二级索引（非聚簇索引）找到对应的主键值，到聚簇索引中查找整行数据，这个过程就是回表



覆盖索引

**覆盖索引**是指查询使用了索引，并且需要返回的列，在该索引中已经能够全部找得到

![image-20231230220950503](https://s2.loli.net/2024/03/08/qh8PXObM1TZpESF.png)



MySQL超大分页处理

在数据量比较大的时候，如果进行limit分页查询，在查询时，越往后，分页查询效率越低

优化思路：一般分页查询时，通过创建**覆盖索引**能够比较好的提升性能，可以通过**覆盖索引**加**子查询**形式进行优化



索引创建原则

![image-20231231124825749](https://s2.loli.net/2024/03/08/dfgbqQK8WjIG235.png)

什么情况下索引会失效？

1. 违反了最左前缀法则
2. 范围查询右边的列
3. 在索引列上进行运算操作
4. 字符串不加单引号（隐式类型转换）
5. 以%开头的Like模糊查询，导致索引失效，仅尾部模糊匹配则不会



SQL优化经验

![image-20231231132223273](https://s2.loli.net/2024/03/08/dLNVpezsJFZy39b.png)

![image-20231231132833872](https://s2.loli.net/2024/03/08/FsubCfwTey576QD.png)

### 3. 事务的特性

![image-20240106214949389](/Users/xiyuan/Documents/Typora/技术文档/Java面试笔记.assets/image-20240106214949389.png)

并发事务问题

![image-20240106215300844](https://s2.loli.net/2024/03/08/AhMIVRg5XH7m9Yv.png)

怎么解决并发事务问题？

![image-20240106215633463](https://s2.loli.net/2024/03/08/bm5yQ6XCiZhlpJx.png)



undo log和redo log的区别

![image-20240106220024943](https://s2.loli.net/2024/03/08/asDX93xH685w2pl.png)

![image-20240106220654887](https://s2.loli.net/2024/03/08/C76pNsxoEZmukfz.png)

![image-20240106220633733](https://s2.loli.net/2024/03/08/s6aybRHJwPeiBo2.png)

事务中的隔离性是如何保证的？

- 锁：排他锁（如一个事务获取了一行的排他锁，其他事务则不能再获取该行的其他锁）
- MVCC：多版本并发控制

![image-20240106225321916](https://s2.loli.net/2024/03/08/e5sCwhoA3RJVSQZ.png)

解释一下MVCC

![image-20240106221458999](https://s2.loli.net/2024/03/08/vxAqrnGwEZgjd6b.png)

![image-20240106221541964](https://s2.loli.net/2024/03/08/P7FeNd3YWbwlirt.png)

![image-20240106222844693](https://s2.loli.net/2024/03/08/u3tEJMCfkhaiwge.png)

### 4. 主从同步原理

![image-20240106225528664](https://s2.loli.net/2024/03/08/gSYHrxPks96Jmlu.png)

![image-20240106225744605](https://s2.loli.net/2024/03/08/1AfL9EDjpqoycrW.png)